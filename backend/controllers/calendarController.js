const Calendar = require('../models/calendarModel');
const Family = require('../models/familyModel');
const Comment = require('../models/commentModel');
const EmotionEntry = require('../models/emotionEntryModel');
const User = require('../models/userModel');

// exports.getEmotionCalendarDataOfFamily = async (req, res, next) => {
//   try {
//     const { familyId } = req.params;
//     console.log('famid', familyId);

//     // B∆∞·ªõc 1: T√¨m t·∫•t c·∫£ User thu·ªôc gia ƒë√¨nh n√†y
//     const users = await User.find({ familyId });
//     const userIds = users.map((user) => user._id); // L·∫•y danh s√°ch userId

//     // B∆∞·ªõc 2: Truy v·∫•n t·∫•t c·∫£ EmotionEntry v√† Comment c·ªßa c√°c User n√†y
//     const emotionEntries = await EmotionEntry.find({
//       userId: { $in: userIds },
//     });
//     const comments = await Comment.find({ userId: { $in: userIds } });

//     console.log('comments', comments);
//     console.log('emotionEntries', emotionEntries);

//     // B∆∞·ªõc 3: T·∫°o m·ªôt map ƒë·ªÉ l∆∞u th√¥ng tin user (username v√† avatar)
//     const userMap = {};
//     users.forEach((user) => {
//       userMap[user._id] = {
//         username: user.username,
//         avatar: user.avatar,
//       };
//     });

//     // B∆∞·ªõc 4: H√†m √°nh x·∫° emoji th√†nh bi·ªÉu t∆∞·ª£ng m·∫∑t
//     const mapEmoji = (emoji) => {
//       switch (emoji) {
//         case 'Happy':
//           return 'üòä';
//         case 'Sad':
//           return 'üò¢';
//         case 'Angry':
//           return 'üò°';
//         case 'Tired':
//           return 'üò¥';
//         case 'Joyful':
//           return 'üòÇ';
//         case 'Surprised':
//           return 'üòÆ';
//         case 'Anxious':
//           return 'üò∞';
//         case 'Loved':
//           return '‚ù§Ô∏è';
//         case 'Peaceful':
//           return 'üòå';
//         case 'Thoughtful':
//           return 'ü§î';
//         default:
//           return '';
//       }
//     };

//     // B∆∞·ªõc 5: Nh√≥m d·ªØ li·ªáu theo dateString
//     const calendarData = {};

//     // X·ª≠ l√Ω EmotionEntry
//     emotionEntries.forEach((entry) => {
//       const { dateString, userId, emoji, note } = entry;

//       if (!calendarData[dateString]) {
//         calendarData[dateString] = {
//           discussion: { comments: [] },
//         };
//       }

//       // Th√™m th√¥ng tin user v√† √°nh x·∫° emoji
//       calendarData[dateString][userMap[userId].username] = {
//         emoji: mapEmoji(emoji),
//         note,
//         username: userMap[userId].username, // Th√™m username c·ªßa user
//       };
//     });

//     // X·ª≠ l√Ω Comment
//     comments.forEach((comment) => {
//       const { dateString, userId, content, createdAt } = comment;

//       if (!calendarData[dateString]) {
//         calendarData[dateString] = {
//           discussion: { comments: [] },
//         };
//       }

//       calendarData[dateString].discussion.comments.push({
//         userId,
//         text: content,
//         timestamp: createdAt,
//         username: userMap[userId].username, // Th√™m username c·ªßa user
//       });
//     });

//     return res.status(200).json({ calendar: calendarData });
//   } catch (error) {
//     console.error('L·ªói khi l·∫•y d·ªØ li·ªáu calendar', error);
//     return res.status(500).json({
//       message: 'L·ªói m√°y ch·ªß',
//       status: 500,
//     });
//   }
// };

///new
exports.getEmotionCalendarDataOfFamily = async (req, res, next) => {
  try {
    const { familyId } = req.params;

    // Get all users in the family
    const users = await User.find({ familyId });
    const userIds = users.map((user) => user._id);

    // Get all calendars for this family
    const calendar = await Calendar.findOne({
      familyId,
      calendarType: 'emotion',
    });

    if (!calendar) {
      return res.status(404).json({
        message: 'Calendar not found for this family',
        status: 404,
      });
    }

    // Get all emotion entries for all dates in the calendar
    const emotionEntries = await EmotionEntry.find({
      userId: { $in: userIds },
      dateString: { $in: calendar.dateStringArray },
    });

    // Get all comments for all dates in the calendar
    const comments = await Comment.find({
      userId: { $in: userIds },
      dateString: { $in: calendar.dateStringArray },
    });

    // Create user map for easy lookup
    const userMap = {};
    users.forEach((user) => {
      userMap[user._id] = {
        username: user.username,
        avatar: user.avatar,
      };
    });

    // Map emoji to display format
    const mapEmoji = (emoji) => {
      switch (emoji) {
        case 'Happy':
          return 'üòä';
        case 'Sad':
          return 'üò¢';
        case 'Angry':
          return 'üò°';
        case 'Tired':
          return 'üò¥';
        case 'Joyful':
          return 'üòÇ';
        case 'Surprised':
          return 'üòÆ';
        case 'Anxious':
          return 'üò∞';
        case 'Loved':
          return '‚ù§Ô∏è';
        case 'Peaceful':
          return 'üòå';
        case 'Thoughtful':
          return 'ü§î';
        default:
          return '';
      }
    };

    // Initialize calendar data with all dates from the calendar
    const calendarData = {};
    calendar.dateStringArray.forEach((date) => {
      calendarData[date] = {
        discussion: { comments: [] },
      };
      // Initialize empty emotion data for all users
      users.forEach((user) => {
        calendarData[date][user.username] = {
          emoji: '',
          note: '',
          username: user.username,
        };
      });
    });

    // Add emotion entries
    emotionEntries.forEach((entry) => {
      const { dateString, userId, emoji, note } = entry;
      const username = userMap[userId].username;
      if (calendarData[dateString]) {
        calendarData[dateString][username] = {
          emoji: mapEmoji(emoji),
          note,
          username,
        };
      }
    });

    // Add comments
    comments.forEach((comment) => {
      const { dateString, userId, content, createdAt } = comment;
      if (calendarData[dateString]) {
        calendarData[dateString].discussion.comments.push({
          userId,
          text: content,
          timestamp: createdAt.toISOString(),
        });
      }
    });

    // Format final response
    const responseData = {
      [familyId]: {
        members: users.map((user) => ({
          id: user._id,
          name: user.username,
          avatar: user.avatar,
        })),
        calendar: calendarData,
      },
    };

    return res.status(200).json(responseData);
  } catch (error) {
    console.error('Error getting calendar data:', error);
    return res.status(500).json({
      message: 'Server error',
      status: 500,
      error: error.message,
    });
  }
};

// T·∫°o 2 calendar m·∫∑c ƒë·ªãnh cho gia ƒë√¨nh m·ªõi
exports.createCalendarForNewFamily = async (req, res, next) => {
  try {
    const { familyId } = req.params;

    // Ki·ªÉm tra gia ƒë√¨nh c√≥ t·ªìn t·∫°i kh√¥ng
    const existingFamily = await Family.findById(familyId);
    if (!existingFamily) {
      return res.status(404).json({
        message: 'Gia ƒë√¨nh kh√¥ng t·ªìn t·∫°i',
        status: 404,
      });
    }

    // Ki·ªÉm tra xem ƒë√£ c√≥ Calendar n√†o cho gia ƒë√¨nh n√†y ch∆∞a
    const existingCalendars = await Calendar.find({ familyId });
    if (existingCalendars.length > 0) {
      return res.status(400).json({
        message: 'Gia ƒë√¨nh ƒë√£ c√≥ Calendar, kh√¥ng th·ªÉ t·∫°o m·ªõi',
        status: 400,
      });
    }

    // T·∫°o 2 b·∫£n ghi Calendar m·∫∑c ƒë·ªãnh
    const emotionCalendar = await Calendar.create({
      dateStringArray: [], // M·∫£ng r·ªóng
      calendarType: 'emotion', // Lo·∫°i Calendar: emotion
      familyId,
    });

    const specialDaysCalendar = await Calendar.create({
      dateStringArray: [], // M·∫£ng r·ªóng
      calendarType: 'special days', // Lo·∫°i Calendar: special days
      familyId,
    });

    // Tr·∫£ v·ªÅ k·∫øt qu·∫£
    return res.status(200).json({
      message: 'T·∫°o th√†nh c√¥ng 2 Calendar m·∫∑c ƒë·ªãnh',
      emotionCalendar,
      specialDaysCalendar,
    });
  } catch (error) {
    console.error('L·ªói khi t·∫°o calendar', error);
    return res.status(500).json({
      message: 'L·ªói m√°y ch·ªß',
      status: 500,
    });
  }
};

exports.updateSpecialDaysCalendar = async (req, res, next) => {
  try {
    const { familyId } = req.params;
    const { dateStringArray } = req.body; // M·∫£ng ch·ª©a c√°c ng√†y m·ªõi c·∫ßn th√™m

    // Ki·ªÉm tra gia ƒë√¨nh c√≥ t·ªìn t·∫°i kh√¥ng
    const existingFamily = await Family.findById(familyId);
    if (!existingFamily) {
      return res.status(404).json({
        message: 'Gia ƒë√¨nh kh√¥ng t·ªìn t·∫°i',
        status: 404,
      });
    }

    // T√¨m Calendar lo·∫°i "special days" c·ªßa gia ƒë√¨nh n√†y
    const specialDaysCalendar = await Calendar.findOne({
      familyId,
      calendarType: 'special days',
    });

    if (!specialDaysCalendar) {
      return res.status(404).json({
        message: 'Kh√¥ng t√¨m th·∫•y Calendar lo·∫°i special days',
        status: 404,
      });
    }

    // Ki·ªÉm tra xem c√°c ng√†y m·ªõi c√≥ tr√πng v·ªõi ng√†y ƒë√£ t·ªìn t·∫°i kh√¥ng
    const duplicateDates = dateStringArray.filter((dateString) =>
      specialDaysCalendar.dateStringArray.includes(dateString)
    );

    if (duplicateDates.length > 0) {
      return res.status(400).json({
        message: `C√°c ng√†y sau ƒë√£ t·ªìn t·∫°i trong l·ªãch: ${duplicateDates.join(
          ', '
        )}`,
        status: 400,
      });
    }

    // Th√™m c√°c ng√†y m·ªõi v√†o m·∫£ng dateStringArray
    specialDaysCalendar.dateStringArray.push(...dateStringArray);
    await specialDaysCalendar.save();

    return res.status(200).json({
      message: 'C·∫≠p nh·∫≠t th√†nh c√¥ng Calendar lo·∫°i special days',
      specialDaysCalendar,
    });
  } catch (error) {
    console.error('L·ªói khi c·∫≠p nh·∫≠t Calendar lo·∫°i special days', error);
    return res.status(500).json({
      message: 'L·ªói m√°y ch·ªß',
      status: 500,
    });
  }
};

exports.updateEmotionCalendar = async (req, res, next) => {
  try {
    const { familyId } = req.params;
    const { dateStringArray } = req.body; // M·∫£ng ch·ª©a c√°c ng√†y m·ªõi c·∫ßn th√™m

    // Ki·ªÉm tra gia ƒë√¨nh c√≥ t·ªìn t·∫°i kh√¥ng
    const existingFamily = await Family.findById(familyId);
    if (!existingFamily) {
      return res.status(404).json({
        message: 'Gia ƒë√¨nh kh√¥ng t·ªìn t·∫°i',
        status: 404,
      });
    }

    // T√¨m Calendar lo·∫°i "emotion" c·ªßa gia ƒë√¨nh n√†y
    const emotionCalendar = await Calendar.findOne({
      familyId,
      calendarType: 'emotion',
    });

    if (!emotionCalendar) {
      return res.status(404).json({
        message: 'Kh√¥ng t√¨m th·∫•y Calendar lo·∫°i emotion',
        status: 404,
      });
    }

    // Ki·ªÉm tra xem c√°c ng√†y m·ªõi c√≥ tr√πng v·ªõi ng√†y ƒë√£ t·ªìn t·∫°i kh√¥ng
    const duplicateDates = dateStringArray.filter((dateString) =>
      emotionCalendar.dateStringArray.includes(dateString)
    );

    if (duplicateDates.length > 0) {
      return res.status(400).json({
        message: `C√°c ng√†y sau ƒë√£ t·ªìn t·∫°i trong l·ªãch: ${duplicateDates.join(
          ', '
        )}`,
        status: 400,
      });
    }

    // Th√™m c√°c ng√†y m·ªõi v√†o m·∫£ng dateStringArray
    emotionCalendar.dateStringArray.push(...dateStringArray);
    await emotionCalendar.save();

    return res.status(200).json({
      message: 'C·∫≠p nh·∫≠t th√†nh c√¥ng Calendar lo·∫°i emotion',
      emotionCalendar,
    });
  } catch (error) {
    console.error('L·ªói khi c·∫≠p nh·∫≠t Calendar lo·∫°i emotion', error);
    return res.status(500).json({
      message: 'L·ªói m√°y ch·ªß',
      status: 500,
    });
  }
};

// Add new endpoint to update emotion
exports.updateEmotion = async (req, res) => {
  try {
    const { familyId, userId, date, emotion } = req.body;

    // Create or update emotion entry
    const emotionEntry = await EmotionEntry.findOneAndUpdate(
      { userId, dateString: date },
      {
        emoji: emotion.emoji,
        note: emotion.note,
        dateString: date,
        userId,
      },
      { upsert: true, new: true }
    );

    // Update calendar entry if needed
    const calendar = await Calendar.findOne({
      familyId,
      calendarType: 'emotion',
    });

    if (!calendar.dateStringArray.includes(date)) {
      calendar.dateStringArray.push(date);
      await calendar.save();
    }

    // Get all users in the family
    const users = await User.find({ familyId });
    const userIds = users.map((user) => user._id);

    // Get all emotion entries for this date
    const emotionEntries = await EmotionEntry.find({
      dateString: date,
      userId: { $in: userIds },
    });

    // Get all comments for this date
    const comments = await Comment.find({
      dateString: date,
      userId: { $in: userIds },
    });

    // Create user map for easy lookup
    const userMap = {};
    users.forEach((user) => {
      userMap[user._id] = {
        username: user.username,
        avatar: user.avatar,
      };
    });

    // Format the response data
    const dateData = {
      discussion: {
        comments: comments.map((comment) => ({
          userId: comment.userId,
          text: comment.content,
          timestamp: comment.createdAt.toISOString(),
        })),
      },
    };

    // Add emotion data for each user
    users.forEach((user) => {
      const userEntry = emotionEntries.find(
        (entry) => entry.userId.toString() === user._id.toString()
      );
      dateData[user.username] = {
        emoji: userEntry ? userEntry.emoji : '',
        note: userEntry ? userEntry.note : '',
        username: user.username,
      };
    });

    // Calculate emotion statistics
    const emotionStats = {};
    let totalVotes = 0;
    emotionEntries.forEach((entry) => {
      if (entry.emoji) {
        emotionStats[entry.emoji] = (emotionStats[entry.emoji] || 0) + 1;
        totalVotes++;
      }
    });

    // Calculate percentages
    const emotionPercentages = {};
    Object.entries(emotionStats).forEach(([emoji, count]) => {
      emotionPercentages[emoji] = Math.round((count / totalVotes) * 100);
    });

    dateData.emotionStats = emotionPercentages;

    res.status(200).json({
      [familyId]: {
        members: users.map((user) => ({
          id: user._id,
          name: user.username,
          avatar: user.avatar,
        })),
        calendar: {
          [date]: dateData,
        },
      },
    });
  } catch (error) {
    console.error('Error updating emotion:', error);
    res.status(500).json({
      message: 'Error updating emotion',
      error: error.message,
    });
  }
};

// Add new endpoint to add comment
exports.addComment = async (req, res) => {
  try {
    const { familyId, date, comment } = req.body;

    // Create new comment
    const newComment = await Comment.create({
      content: comment.text,
      dateString: date,
      userId: comment.userId,
      createdAt: comment.timestamp,
    });

    // Update calendar entry if needed
    const calendar = await Calendar.findOne({
      familyId,
      calendarType: 'emotion',
    });

    if (!calendar.dateStringArray.includes(date)) {
      calendar.dateStringArray.push(date);
      await calendar.save();
    }

    // Get all users in the family
    const users = await User.find({ familyId });
    const userIds = users.map((user) => user._id);

    // Get all emotion entries for this date
    const emotionEntries = await EmotionEntry.find({
      dateString: date,
      userId: { $in: userIds },
    });

    // Get all comments for this date
    const comments = await Comment.find({
      dateString: date,
      userId: { $in: userIds },
    });

    // Create user map for easy lookup
    const userMap = {};
    users.forEach((user) => {
      userMap[user._id] = {
        username: user.username,
        avatar: user.avatar,
      };
    });

    // Format the response data
    const dateData = {
      discussion: {
        comments: comments.map((comment) => ({
          userId: comment.userId,
          text: comment.content,
          timestamp: comment.createdAt.toISOString(),
        })),
      },
    };

    // Add emotion data for each user
    emotionEntries.forEach((entry) => {
      const username = userMap[entry.userId].username;
      dateData[username] = {
        emoji: entry.emoji,
        note: entry.note,
        username: username,
      };
    });

    res.status(200).json({
      [familyId]: {
        members: users.map((user) => ({
          id: user._id,
          name: user.username,
          avatar: user.avatar,
        })),
        calendar: {
          [date]: dateData,
        },
      },
    });
  } catch (error) {
    console.error('Error adding comment:', error);
    res.status(500).json({
      message: 'Error adding comment',
      error: error.message,
    });
  }
};
